{"version":3,"sources":["webpack://livecodelang/webpack/bootstrap","webpack://livecodelang/./node_modules/canto34/dist/canto34.js","webpack://livecodelang/./src/ast/index.js","webpack://livecodelang/./src/ast/types.js","webpack://livecodelang/./src/index.js","webpack://livecodelang/./src/parser/index.js","webpack://livecodelang/./src/parser/lexer.js"],"names":["Null","Block","Assignment","Application","If","Lambda","Times","UnaryOp","BinaryOp","DeIndex","Num","Variable","Str","List","type","NULL","elements","BLOCK","variable","expression","ASSIGNMENT","func","args","APPLICATION","predicate","ifBlock","elseBlock","IF","argNames","body","LAMBDA","number","block","loopVar","TIMES","operator","expr1","UNARYOP","expr2","BINARYOP","collection","index","DEINDEX","value","NUMBER","identifier","VARIABLE","STRING","values","LIST","parser","lexer","ast","Parser","tokens","ParserException","Array","tokenType","eof","n","la1","line","character","shift","length","result","match","push","statement","newline","lan","application","assignment","name","content","expr","argList","lambda","nameList","names","canto34","types","StandardTokenTypes","Lexer","languageName","regexp","addToken","whitespace","constant","comma","openParen","closeParen","openBracket","closeBracket","integer","floatingPoint"],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AAAA;AAAA;AAAA;AACA,EAAE,kBAQF;AACA,CAAC;AACD;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,2BAA2B;AAC3B;AACA,GAAG;AACH;AACA;AACA,2BAA2B;AAC3B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2BAA2B;AAC3B;AACA,2BAA2B;AAC3B;AACA;AACA,iDAAiD,EAAE;AACnD;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;;;;;;QC1hBeA,I,GAAAA,I;QASAC,K,GAAAA,K;QAWAC,U,GAAAA,U;QAYAC,W,GAAAA,W;QAaAC,E,GAAAA,E;QAcAC,M,GAAAA,M;QAaAC,K,GAAAA,K;QAaAC,O,GAAAA,O;QAaAC,Q,GAAAA,Q;QAaAC,O,GAAAA,O;QAWAC,G,GAAAA,G;QAUAC,Q,GAAAA,Q;QAUA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","file":"livecodelang.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","(function (global, factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine([\"exports\"], factory);\n\t} else if (typeof exports !== \"undefined\") {\n\t\tfactory(exports);\n\t} else {\n\t\tvar mod = {\n\t\t\texports: {}\n\t\t};\n\t\tfactory(mod.exports);\n\t\tglobal.canto34 = mod.exports;\n\t}\n})(this, function (exports) {\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\n\tvar _createClass = function () {\n\t\tfunction defineProperties(target, props) {\n\t\t\tfor (var i = 0; i < props.length; i++) {\n\t\t\t\tvar descriptor = props[i];\n\t\t\t\tdescriptor.enumerable = descriptor.enumerable || false;\n\t\t\t\tdescriptor.configurable = true;\n\t\t\t\tif (\"value\" in descriptor) descriptor.writable = true;\n\t\t\t\tObject.defineProperty(target, descriptor.key, descriptor);\n\t\t\t}\n\t\t}\n\n\t\treturn function (Constructor, protoProps, staticProps) {\n\t\t\tif (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\t\tif (staticProps) defineProperties(Constructor, staticProps);\n\t\t\treturn Constructor;\n\t\t};\n\t}();\n\n\tfunction _classCallCheck(instance, Constructor) {\n\t\tif (!(instance instanceof Constructor)) {\n\t\t\tthrow new TypeError(\"Cannot call a class as a function\");\n\t\t}\n\t}\n\n\tfunction _possibleConstructorReturn(self, call) {\n\t\tif (!self) {\n\t\t\tthrow new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t\t}\n\n\t\treturn call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t}\n\n\tfunction _inherits(subClass, superClass) {\n\t\tif (typeof superClass !== \"function\" && superClass !== null) {\n\t\t\tthrow new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t\t}\n\n\t\tsubClass.prototype = Object.create(superClass && superClass.prototype, {\n\t\t\tconstructor: {\n\t\t\t\tvalue: subClass,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t}\n\t\t});\n\t\tif (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t}\n\n\tvar util = {\n\t\tlang: {\n\t\t\tisNullOrUndefined: function isNullOrUndefined(x) {\n\t\t\t\tif (typeof x === \"undefined\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (x === null) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\textend: function extend() {\n\t\t\t// conparable to jquery's extend\n\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\tfor (var key in arguments[i]) {\n\t\t\t\t\tif (arguments[i].hasOwnProperty(key)) arguments[0][key] = arguments[i][key];\n\t\t\t\t}\n\t\t\t}return arguments[0];\n\t\t}\n\t};\n\n\tvar PatternDefinitionException = function (_Error) {\n\t\t_inherits(PatternDefinitionException, _Error);\n\n\t\tfunction PatternDefinitionException(message) {\n\t\t\t_classCallCheck(this, PatternDefinitionException);\n\n\t\t\treturn _possibleConstructorReturn(this, (PatternDefinitionException.__proto__ || Object.getPrototypeOf(PatternDefinitionException)).call(this, message));\n\t\t}\n\n\t\treturn PatternDefinitionException;\n\t}(Error);\n\n\tvar LexerException = function (_Error2) {\n\t\t_inherits(LexerException, _Error2);\n\n\t\tfunction LexerException(message) {\n\t\t\t_classCallCheck(this, LexerException);\n\n\t\t\treturn _possibleConstructorReturn(this, (LexerException.__proto__ || Object.getPrototypeOf(LexerException)).call(this, message));\n\t\t}\n\n\t\treturn LexerException;\n\t}(Error);\n\n\tvar ParserException = function (_Error3) {\n\t\t_inherits(ParserException, _Error3);\n\n\t\tfunction ParserException(message) {\n\t\t\t_classCallCheck(this, ParserException);\n\n\t\t\treturn _possibleConstructorReturn(this, (ParserException.__proto__ || Object.getPrototypeOf(ParserException)).call(this, message));\n\t\t}\n\n\t\treturn ParserException;\n\t}(Error);\n\n\tvar Lexer = function () {\n\t\tfunction Lexer(options) {\n\t\t\t_classCallCheck(this, Lexer);\n\n\t\t\tvar defaults = {\n\t\t\t\tlanguageName: \"unnamedlanguage\"\n\t\t\t};\n\t\t\tthis.options = util.extend({}, defaults, options);\n\t\t\tthis.tokenTypes = [];\n\t\t}\n\n\t\t_createClass(Lexer, [{\n\t\t\tkey: \"addTokenType\",\n\t\t\tvalue: function addTokenType(tokenType) {\n\n\t\t\t\tif (!tokenType.name) {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types must have a 'name' property\");\n\t\t\t\t}\n\n\t\t\t\t// FOR CONSIDERATION: for some tokens, the full 'consume' is required for correct interpretation\n\t\t\t\t// (eg, JSON strings with escaped character) but a regex will do for syntax highlighting. In this\n\t\t\t\t// situation, both are allowed but consume is used for lexing and regexp is used for language definition.\n\t\t\t\t// if (tokenType.regexp && tokenType.consume) {\n\t\t\t\t// \tthrow new canto34.PatternDefinitionException(\"Token types cannot have both a 'regexp' pattern and 'consume' function.\");\n\t\t\t\t// }\n\n\t\t\t\tif (!tokenType.regexp && !tokenType.consume) {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types must have a 'regexp' property or a 'consume' function\");\n\t\t\t\t}\n\n\t\t\t\tif (tokenType.regexp && !(tokenType.regexp instanceof RegExp)) {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types 'regexp' property must be an instance of RegExp\");\n\t\t\t\t}\n\n\t\t\t\tif (tokenType.consume && typeof tokenType.consume !== \"function\") {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types 'consume' property must be a function\");\n\t\t\t\t}\n\n\t\t\t\tif (tokenType.interpret && typeof tokenType.interpret !== \"function\") {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types 'interpret' property must be a function\");\n\t\t\t\t}\n\t\t\t\tthis.tokenTypes.push(tokenType);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"tokenize\",\n\t\t\tvalue: function tokenize(content) {\n\t\t\t\tif (content === undefined) {\n\t\t\t\t\tthrow new LexerException(\"No content provided\");\n\t\t\t\t}\n\n\t\t\t\tif (this.tokenTypes.length === 0) {\n\t\t\t\t\tthrow new LexerException(\"No token types defined\");\n\t\t\t\t}\n\n\t\t\t\tvar result = [];\n\t\t\t\tvar consumed;\n\t\t\t\tvar remaining = content;\n\t\t\t\tvar tracker = new LineTracker();\n\t\t\t\tvar tokenTypeLength = this.tokenTypes.length;\n\t\t\t\tvar consumeResult;\n\n\t\t\t\twhile (remaining.length > 0) {\n\t\t\t\t\tvar somethingFoundThisPass = false;\n\n\t\t\t\t\tfor (var i = 0; i < tokenTypeLength; i++) {\n\t\t\t\t\t\tvar tokenType = this.tokenTypes[i];\n\n\t\t\t\t\t\tconsumeResult = undefined;\n\t\t\t\t\t\tif (tokenType.consume) {\n\t\t\t\t\t\t\t// must have a consume function;\n\t\t\t\t\t\t\tconsumeResult = tokenType.consume(remaining);\n\t\t\t\t\t\t\t// should have told us what it consumed;\n\t\t\t\t\t\t\tif (consumeResult.success) {\n\t\t\t\t\t\t\t\tif (remaining.indexOf(consumeResult.consumed) !== 0) {\n\t\t\t\t\t\t\t\t\tthrow new LexerException(\"The consume function for \" + tokenType.name + \" failed to return the start of the remaining content at \" + tracker.line + \".\" + tracker.character + \" and instead returned \" + consumeResult.consumed);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tsomethingFoundThisPass = true;\n\t\t\t\t\t\t\t\t\tconsumed = consumeResult.consumed;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar match = tokenType.regexp.exec(remaining);\n\t\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t\t// we found a token! great. What did it say? We only\n\t\t\t\t\t\t\t\t// want to match at the start of the string\n\t\t\t\t\t\t\t\tif (match.index === 0) {\n\t\t\t\t\t\t\t\t\tsomethingFoundThisPass = true;\n\t\t\t\t\t\t\t\t\tconsumed = match[0];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//handle our new token\n\t\t\t\t\t\tif (tokenType.interpret) {\n\t\t\t\t\t\t\tcontent = tokenType.interpret(consumed);\n\t\t\t\t\t\t} else if (consumeResult && !util.lang.isNullOrUndefined(consumeResult.content)) {\n\t\t\t\t\t\t\tcontent = consumeResult.content;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent = consumed;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = {\n\t\t\t\t\t\t\tcontent: content,\n\t\t\t\t\t\t\ttype: tokenType.name,\n\t\t\t\t\t\t\tline: tracker.line,\n\t\t\t\t\t\t\tcharacter: tracker.character\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!tokenType.ignore) {\n\t\t\t\t\t\t\tresult.push(token);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tremaining = remaining.substring(consumed.length);\n\t\t\t\t\t\ttracker.consume(consumed);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!somethingFoundThisPass) {\n\t\t\t\t\t\tvar userPartOfString = remaining.substring(0, 15);\n\t\t\t\t\t\tvar visibleUserPartOfString = userPartOfString.replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\").replace(\"\\n\", \"\\\\n\");\n\t\t\t\t\t\tthrow new LexerException(\"No viable alternative at \" + tracker.line + \".\" + tracker.character + \": '\" + visibleUserPartOfString + \"...'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}]);\n\n\t\treturn Lexer;\n\t}();\n\n\tfunction escapeRegExp(string) {\n\t\treturn string.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n\t}\n\n\tvar StandardTokenTypes = function () {\n\t\tfunction StandardTokenTypes() {\n\t\t\t_classCallCheck(this, StandardTokenTypes);\n\t\t}\n\n\t\t_createClass(StandardTokenTypes, null, [{\n\t\t\tkey: \"constant\",\n\t\t\tvalue: function constant(literal, name, role) {\n\t\t\t\trole = role || [\"keyword\"];\n\t\t\t\treturn {\n\t\t\t\t\tname: name,\n\t\t\t\t\tregexp: new RegExp(\"^\" + escapeRegExp(literal)),\n\t\t\t\t\trole: role\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"floatingPoint\",\n\t\t\tvalue: function floatingPoint() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"floating point\",\n\t\t\t\t\tregexp: /(^-?\\d*\\.\\d+)/,\n\t\t\t\t\trole: [\"constant\", \"numeric\"],\n\t\t\t\t\tinterpret: function interpret(content) {\n\t\t\t\t\t\treturn parseFloat(content);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"integer\",\n\t\t\tvalue: function integer() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"integer\",\n\t\t\t\t\tregexp: /^-?\\d+/,\n\t\t\t\t\trole: [\"constant\", \"numeric\"],\n\t\t\t\t\tinterpret: function interpret(content) {\n\t\t\t\t\t\treturn parseInt(content);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"whitespace\",\n\t\t\tvalue: function whitespace() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"whitespace\",\n\t\t\t\t\tignore: true,\n\t\t\t\t\tregexp: /^[ \\t]+/\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"whitespaceWithNewlines\",\n\t\t\tvalue: function whitespaceWithNewlines() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"whitespace\",\n\t\t\t\t\tignore: true,\n\t\t\t\t\tregexp: /^[ \\t\\r\\n]+/\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"real\",\n\t\t\tvalue: function real() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"real number\",\n\t\t\t\t\tregexp: /^X/,\n\t\t\t\t\trole: [\"constant\", \"numeric\"]\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"comma\",\n\t\t\tvalue: function comma() {\n\t\t\t\treturn this.constant(\",\", \"comma\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"period\",\n\t\t\tvalue: function period() {\n\t\t\t\treturn this.constant(\".\", \"period\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"star\",\n\t\t\tvalue: function star() {\n\t\t\t\treturn this.constant(\"*\", \"star\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"colon\",\n\t\t\tvalue: function colon() {\n\t\t\t\treturn this.constant(\":\", \"colon\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"openParen\",\n\t\t\tvalue: function openParen() {\n\t\t\t\treturn this.constant(\"(\", \"open paren\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"closeParen\",\n\t\t\tvalue: function closeParen() {\n\t\t\t\treturn this.constant(\")\", \"close paren\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"openBracket\",\n\t\t\tvalue: function openBracket() {\n\t\t\t\treturn this.constant(\"{\", \"open bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"closeBracket\",\n\t\t\tvalue: function closeBracket() {\n\t\t\t\treturn this.constant(\"}\", \"close bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"openSquareBracket\",\n\t\t\tvalue: function openSquareBracket() {\n\t\t\t\treturn this.constant(\"[\", \"open square bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"closeSquareBracket\",\n\t\t\tvalue: function closeSquareBracket() {\n\t\t\t\treturn this.constant(\"]\", \"close square bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"JsonString\",\n\t\t\tvalue: function JsonString() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"string\",\n\t\t\t\t\tregexp: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\t\t\tconsume: function consume(remaining) {\n\t\t\t\t\t\tvar fail = { success: false };\n\t\t\t\t\t\tif (remaining.indexOf('\"') !== 0) {\n\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar content = '';\n\t\t\t\t\t\tvar pos = 1;\n\t\t\t\t\t\tvar ch;\n\t\t\t\t\t\tvar finished = false;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tch = remaining[pos];\n\t\t\t\t\t\t\tpos += 1;\n\n\t\t\t\t\t\t\tswitch (ch) {\n\t\t\t\t\t\t\t\tcase '\"':\n\t\t\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\t\t\t\tvar ch2 = remaining[pos];\n\t\t\t\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\t\t\t\tswitch (ch2) {\n\t\t\t\t\t\t\t\t\t\tcase '\"':\n\t\t\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t\t\tcase \"t\":\n\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\t\";break;\n\t\t\t\t\t\t\t\t\t\tcase \"r\":\n\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\r\";break;\n\t\t\t\t\t\t\t\t\t\tcase \"n\":\n\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\n\";break;\n\t\t\t\t\t\t\t\t\t\tcase \"u\":\n\t\t\t\t\t\t\t\t\t\t\tvar unicodeDigits = remaining.substr(pos, 4);\n\t\t\t\t\t\t\t\t\t\t\tif (unicodeDigits.length != 4 || !/\\d{4}/.test(unicodeDigits)) {\n\t\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\\\u\";\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tpos += 4;\n\t\t\t\t\t\t\t\t\t\t\t\tvar codePoint = parseInt(unicodeDigits, 10);\n\t\t\t\t\t\t\t\t\t\t\t\tvar codePointString = String.fromCharCode(codePoint);\n\t\t\t\t\t\t\t\t\t\t\t\tcontent += codePointString;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t// something like \\q, which doesn't mean anything\n\t\t\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcontent += ch;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (!finished);\n\n\t\t\t\t\t\tvar consumed = remaining.substring(0, pos);\n\n\t\t\t\t\t\tvar successResult = {\n\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\tconsumed: consumed,\n\t\t\t\t\t\t\tcontent: content\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn successResult;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}]);\n\n\t\treturn StandardTokenTypes;\n\t}();\n\n\tvar Parser = function () {\n\t\tfunction Parser() {\n\t\t\t_classCallCheck(this, Parser);\n\t\t}\n\n\t\t_createClass(Parser, [{\n\t\t\tkey: \"initialize\",\n\t\t\tvalue: function initialize(tokens) {\n\t\t\t\tif (!tokens) {\n\t\t\t\t\tthrow new ParserException(\"No tokens provided to the parser\");\n\t\t\t\t}\n\n\t\t\t\tif (!(tokens instanceof Array)) {\n\t\t\t\t\tthrow new ParserException(\"A non-array was provided to the parser instead of a token array\");\n\t\t\t\t}\n\n\t\t\t\tthis.tokens = tokens;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"la1\",\n\t\t\tvalue: function la1(tokenType) {\n\t\t\t\tif (this.eof()) {\n\t\t\t\t\tthrow new ParserException(\"No tokens available\");\n\t\t\t\t}\n\n\t\t\t\treturn this.tokens[0].type == tokenType;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"match\",\n\t\t\tvalue: function match(tokenType) {\n\n\t\t\t\tif (this.eof()) {\n\t\t\t\t\tthrow new ParserException(\"Expected \" + tokenType + \" but found EOF\");\n\t\t\t\t}\n\n\t\t\t\tif (!this.la1(tokenType)) {\n\t\t\t\t\tthrow new ParserException(\"Expected \" + tokenType + \" but found \" + this.tokens[0].type + \" at l\" + this.tokens[0].line + \".\" + this.tokens[0].character);\n\t\t\t\t}\n\n\t\t\t\treturn this.tokens.shift();\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"eof\",\n\t\t\tvalue: function eof() {\n\t\t\t\treturn this.tokens.length === 0;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"expectEof\",\n\t\t\tvalue: function expectEof() {\n\t\t\t\tif (!this.eof()) {\n\t\t\t\t\tthrow new ParserException(\"Expected EOF but found \" + this.tokens[0].type + \" at l\" + this.tokens[0].line + \".\" + this.tokens[0].character);\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\n\t\treturn Parser;\n\t}();\n\n\tvar LineTracker = function () {\n\t\tfunction LineTracker() {\n\t\t\t_classCallCheck(this, LineTracker);\n\n\t\t\tthis.line = 1;\n\t\t\tthis.character = 1;\n\t\t\tthis.justSeenSlashR = false;\n\t\t}\n\n\t\t_createClass(LineTracker, [{\n\t\t\tkey: \"consume\",\n\t\t\tvalue: function consume(content) {\n\n\t\t\t\tfor (var i = 0, len = content.length; i < len; i++) {\n\t\t\t\t\tif (content[i] == \"\\r\") {\n\t\t\t\t\t\tthis.line += 1;\n\t\t\t\t\t\tthis.character = 1;\n\t\t\t\t\t\tthis.justSeenSlashR = true;\n\t\t\t\t\t} else if (content[i] == \"\\n\") {\n\t\t\t\t\t\tif (!this.justSeenSlashR) {\n\t\t\t\t\t\t\tthis.line += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.character = 1;\n\t\t\t\t\t\tthis.justSeenSlashR = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.character += 1;\n\t\t\t\t\t\tthis.justSeenSlashR = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\n\t\treturn LineTracker;\n\t}();\n\n\texports.PatternDefinitionException = PatternDefinitionException;\n\texports.LexerException = LexerException;\n\texports.ParserException = ParserException;\n\texports.Lexer = Lexer;\n\texports.StandardTokenTypes = StandardTokenTypes;\n\texports.Parser = Parser;\n\texports.LineTracker = LineTracker;\n});","import {\n  APPLICATION,\n  ASSIGNMENT,\n  BINARYOP,\n  BLOCK,\n  DEINDEX,\n  IF,\n  LAMBDA,\n  LIST,\n  NUMBER,\n  NULL,\n  STRING,\n  TIMES,\n  UNARYOP,\n  VARIABLE,\n} from './types';\n\n/**\n */\nexport function Null() {\n  return {\n    type: NULL,\n  };\n}\n\n/**\n *  elements: [Element]\n */\nexport function Block(elements) {\n  return {\n    type: BLOCK,\n    elements,\n  };\n}\n\n/**\n *  variable: Variable\n *  expression: Expression\n */\nexport function Assignment(variable, expression) {\n  return {\n    type: ASSIGNMENT,\n    variable,\n    expression,\n  };\n}\n\n/**\n *  func: Identifier\n *  args: [Expression]\n */\nexport function Application(func, args) {\n  return {\n    type: APPLICATION,\n    func,\n    args,\n  };\n}\n\n/**\n *  predicate: Expression\n *  ifBlock:   Block\n *  elseBlock: Block\n */\nexport function If(predicate, ifBlock, elseBlock = Null()) {\n  return {\n    type: IF,\n    predicate,\n    ifBlock,\n    elseBlock,\n  };\n}\n\n/**\n *  argNames:  [Identifier]\n *  body:      Block\n *  inlinable: Boolean\n */\nexport function Lambda(argNames, body) {\n  return {\n    type: LAMBDA,\n    argNames,\n    body,\n  };\n}\n\n/**\n *  number:  Expression\n *  block:   Block\n *  loopVar: Identifier\n */\nexport function Times(number, block, loopVar = Null()) {\n  return {\n    type: TIMES,\n    number,\n    block,\n    loopVar,\n  };\n}\n\n/**\n *  operation: String\n *  expr1: Expression\n */\nexport function UnaryOp(operator, expr1) {\n  return {\n    type: UNARYOP,\n    operator,\n    expr1,\n  };\n}\n\n/**\n *  operation: String\n *  expr1: Expression\n *  expr2: Expression\n */\nexport function BinaryOp(operator, expr1, expr2) {\n  return {\n    type: BINARYOP,\n    operator,\n    expr1,\n    expr2,\n  };\n}\n\n/**\n *  collection: Expression\n *  index: Expression\n */\nexport function DeIndex(collection, index) {\n  return {\n    type: DEINDEX,\n    collection,\n    index,\n  };\n}\n\n/**\n *  value: Number\n */\nexport function Num(value) {\n  return {\n    type: NUMBER,\n    value,\n  };\n}\n\n/**\n *  value: Identifier\n */\nexport function Variable(identifier) {\n  return {\n    type: VARIABLE,\n    identifier,\n  };\n}\n\n/**\n *  value: String\n */\nexport function Str(value) {\n  return {\n    type: STRING,\n    value,\n  };\n}\n\n/**\n *  value: List\n */\nexport function List(values) {\n  return {\n    type: LIST,\n    values,\n  };\n}\n","export const APPLICATION = 'APPLICATION';\nexport const ASSIGNMENT = 'ASSIGNMENT';\nexport const BINARYOP = 'BINARYOP';\nexport const BLOCK = 'BLOCK';\nexport const DEINDEX = 'DEINDEX';\nexport const IF = 'IF';\nexport const LAMBDA = 'LAMBDA';\nexport const LIST = 'LIST';\nexport const NUMBER = 'NUMBER';\nexport const NULL = 'NULL';\nexport const STRING = 'STRING';\nexport const TIMES = 'TIMES';\nexport const UNARYOP = 'UNARYOP';\nexport const VARIABLE = 'VARIABLE';\n","import parser from './parser';\nimport lexer from './parser/lexer';\n\nexport { parser, lexer };\n","import { ParserException } from 'canto34';\n\nimport * as ast from '../ast';\n\nclass Parser {\n  initialize(tokens) {\n    if (!tokens) {\n      throw new ParserException('No tokens provided to the parser');\n    }\n\n    if (!(tokens instanceof Array)) {\n      throw new ParserException(\n        'A non-array was provided to the parser instead of a token array'\n      );\n    }\n\n    this.tokens = tokens;\n  }\n  la1(tokenType) {\n    if (this.eof()) {\n      throw new ParserException('No tokens available');\n    }\n\n    return this.tokens[0].type == tokenType;\n  }\n  lan(n, tokenType) {\n    if (this.eof()) {\n      throw new ParserException('No tokens available');\n    }\n\n    return this.tokens[n - 1].type == tokenType;\n  }\n  match(tokenType) {\n    if (this.eof()) {\n      throw new ParserException(`Expected ${tokenType} but found EOF`);\n    }\n\n    if (!this.la1(tokenType)) {\n      throw new ParserException(\n        'Expected ' +\n          tokenType +\n          ' but found ' +\n          this.tokens[0].type +\n          ' at l' +\n          this.tokens[0].line +\n          '.' +\n          this.tokens[0].character\n      );\n    }\n\n    return this.tokens.shift();\n  }\n  eof() {\n    return this.tokens.length === 0;\n  }\n  expectEof() {\n    if (!this.eof()) {\n      throw new ParserException(\n        'Expected EOF but found ' +\n          this.tokens[0].type +\n          ' at l' +\n          this.tokens[0].line +\n          '.' +\n          this.tokens[0].character\n      );\n    }\n  }\n}\n\nconst parser = new Parser();\n\nparser.body = function() {\n  const result = [];\n  if (this.la1('newline')) {\n    this.match('newline');\n  }\n  while (!this.eof()) {\n    result.push(this.statement());\n    this.newline();\n  }\n  return result;\n};\n\nparser.statement = function() {\n  if (this.lan(2, 'open paren')) {\n    return this.application();\n  }\n  if (this.lan(2, 'assignment')) {\n    return this.assignment();\n  }\n  throw new ParserException('Could not parse either application or assignment');\n};\n\nparser.assignment = function() {\n  const name = this.match('identifier').content;\n  this.match('assignment');\n  const expr = this.expression();\n  return ast.Assignment(name, expr);\n};\n\nparser.application = function() {\n  const name = this.match('identifier').content;\n  this.match('open paren');\n  const args = this.argList();\n  this.match('close paren');\n  this.result.push(ast.Application(name, args));\n};\n\nparser.argList = function() {\n  const args = [];\n  if (this.la1('close paren')) {\n    return args;\n  }\n  args.push(this.expression());\n  while (this.la1('comma')) {\n    this.match('comma');\n    args.push(this.expression());\n  }\n  return args;\n};\n\nparser.expression = function() {\n  let expr1;\n  if (this.la1('floating point')) {\n    expr1 = ast.Num(this.match('floating point'));\n  } else if (this.la1('integer')) {\n    expr1 = ast.Num(this.match('integer'));\n  } else if (this.la1('name') && this.lan(2, 'open paren')) {\n    expr1 = this.application();\n  } else if (this.la1('name')) {\n    expr1 = ast.Variable(this.match('name'));\n  } else if (this.la1('open paren')) {\n    expr1 = this.lambda();\n  }\n  if (!this.la1('operator')) {\n    return expr1;\n  }\n  const operator = this.match('operator');\n  const expr2 = this.expression();\n  return ast.BinaryOp(operator, expr1, expr2);\n};\n\nparser.lambda = function() {\n  this.match('open paren');\n  const argNames = this.nameList();\n  this.match('close paren');\n  this.match('function arrow');\n  this.match('open bracket');\n  const body = this.body();\n  this.match('close bracket');\n  return ast.Lambda(argNames, body);\n};\n\nparser.nameList = function() {\n  const names = [];\n  if (this.la1('close paren')) {\n    return names;\n  }\n  names.push(this.match('name'));\n  while (this.la1('comma')) {\n    this.match('comma');\n    names.push(this.match('name'));\n  }\n  return names;\n};\n\nexport default parser;\n","import * as canto34 from 'canto34';\n\nconst types = canto34.StandardTokenTypes;\n\nconst lexer = new canto34.Lexer({ languageName: 'live-code-lang' });\n\nconst newline = () => ({\n  name: 'newline',\n  regexp: /^(\\n)+[ \\n]*/,\n});\n\nconst identifier = () => ({\n  name: 'identifier',\n  regexp: /^[a-zA-Z][a-zA-Z0-9]*/,\n});\n\nconst operator = () => ({\n  name: 'operator',\n  regexp: /^[*/+-]*/,\n});\n\nlexer.addToken(newline);\nlexer.addToken(types.whitespace());\n\nlexer.addToken(types.constant('=', 'assignment'));\nlexer.addToken(types.comma());\nlexer.addToken(types.constant('=>', 'function arrow'));\nlexer.addToken(types.openParen());\nlexer.addToken(types.closeParen());\nlexer.addToken(types.openBracket());\nlexer.addToken(types.closeBracket());\n\nlexer.addToken(operator());\n\nlexer.addToken(types.integer());\nlexer.addToken(types.floatingPoint());\n\nlexer.addToken(identifier);\n\nexport default lexer;\n"],"sourceRoot":""}