{"version":3,"sources":["webpack://livecodelang/webpack/bootstrap","webpack://livecodelang/./src/ast/types.js","webpack://livecodelang/./src/parser/lexer.js","webpack://livecodelang/./node_modules/canto34/dist/canto34.js","webpack://livecodelang/./src/ast/index.js","webpack://livecodelang/./src/parser/index.js","webpack://livecodelang/./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","APPLICATION","ASSIGNMENT","BINARYOP","BLOCK","DEINDEX","IF","LAMBDA","LIST","LOOP","NUMBER","NULL","RETURN","STRING","UNARYOP","VARIABLE","canto34","types","StandardTokenTypes","lexer","Lexer","languageName","addTokenType","whitespace","regexp","ignore","constant","comma","openParen","closeParen","openBracket","closeBracket","openSquareBracket","closeSquareBracket","floatingPoint","integer","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","_createClass","defineProperties","target","props","length","descriptor","configurable","writable","Constructor","protoProps","staticProps","_classCallCheck","instance","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","constructor","setPrototypeOf","__proto__","util","lang","isNullOrUndefined","x","extend","arguments","PatternDefinitionException","_Error","message","this","getPrototypeOf","Error","LexerException","_Error2","ParserException","_Error3","options","tokenTypes","tokenType","consume","RegExp","interpret","push","content","consumed","consumeResult","result","remaining","tracker","LineTracker","tokenTypeLength","somethingFoundThisPass","success","indexOf","line","character","match","exec","index","token","type","substring","userPartOfString","visibleUserPartOfString","replace","literal","role","string","parseFloat","parseInt","fail","ch","pos","finished","ch2","unicodeDigits","substr","test","codePoint","codePointString","String","fromCharCode","successResult","Parser","tokens","Array","eof","la1","shift","justSeenSlashR","len","apply","Null","Block","elements","Assignment","variable","expression","Application","func","args","If","predicate","ifBlock","elseBlock","Lambda","argNames","body","Return","Loop","number","block","loopVar","UnaryOp","operator","expr1","BinaryOp","expr2","DeIndex","collection","Num","Variable","identifier","Str","List","values","_types","_canto","_lexer","ast","astTypes","ArithmaticShunter","operatorStack","output","precedences","^","*","/","%","+","-","<","<=",">",">=","==","!=","&&","||","op","v2","pop","v1","expr","newOp","peekOp","topOp","collapseOp","parser","_tokens$","_tokens$2","program","statement","ifStatement","loop","lan","assignment","application","exprList","timesExpr","loopBlock","baseExpression","arithmatic","list","_tokens$3","lambda","deindex","deIndexExpr","firstExpr","shunter","shuntValue","shuntOp","getOutput","exprs","argList","map","e","exprListToArgs","nameList","names","parse","tokenize","initialize"],"mappings":"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","file":"livecodelang.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","export const APPLICATION = 'APPLICATION';\nexport const ASSIGNMENT = 'ASSIGNMENT';\nexport const BINARYOP = 'BINARYOP';\nexport const BLOCK = 'BLOCK';\nexport const DEINDEX = 'DEINDEX';\nexport const IF = 'IF';\nexport const LAMBDA = 'LAMBDA';\nexport const LIST = 'LIST';\nexport const LOOP = 'LOOP';\nexport const NUMBER = 'NUMBER';\nexport const NULL = 'NULL';\nexport const RETURN = 'RETURN';\nexport const STRING = 'STRING';\nexport const UNARYOP = 'UNARYOP';\nexport const VARIABLE = 'VARIABLE';\n","import * as canto34 from 'canto34';\n\nconst types = canto34.StandardTokenTypes;\n\nconst lexer = new canto34.Lexer({ languageName: 'live-code-lang' });\n\nconst comment = () => ({\n  name: 'comment',\n  ignore: true,\n  regexp: /^\\/\\/[^\\n]*/,\n});\n\nconst newline = () => ({\n  name: 'newline',\n  regexp: /^\\n[ \\n]*/,\n});\n\nconst identifier = () => ({\n  name: 'identifier',\n  regexp: /^[a-zA-Z][a-zA-Z0-9]*/,\n});\n\nconst operator = () => ({\n  name: 'operator',\n  regexp: /^[|&!<=>^%*/+-]+/,\n});\n\nconst comparrisonOperator = () => ({\n  name: 'operator',\n  regexp: /^==/,\n});\n\nlexer.addTokenType(types.whitespace());\nlexer.addTokenType(newline());\nlexer.addTokenType(comment());\n\nlexer.addTokenType(types.constant('if', 'if'));\nlexer.addTokenType(types.constant('else', 'else'));\nlexer.addTokenType(types.constant('loop', 'loop'));\nlexer.addTokenType(types.constant('times', 'times'));\nlexer.addTokenType(types.constant('with', 'with'));\nlexer.addTokenType(types.constant('return', 'return'));\nlexer.addTokenType(types.constant('=>', 'function arrow'));\n\n// needs to come before assignment\nlexer.addTokenType(comparrisonOperator());\nlexer.addTokenType(types.constant('=', 'assignment'));\n\nlexer.addTokenType(types.comma());\nlexer.addTokenType(types.openParen());\nlexer.addTokenType(types.closeParen());\nlexer.addTokenType(types.openBracket());\nlexer.addTokenType(types.closeBracket());\nlexer.addTokenType(types.openSquareBracket());\nlexer.addTokenType(types.closeSquareBracket());\n\nlexer.addTokenType(operator());\n\nlexer.addTokenType(types.floatingPoint());\nlexer.addTokenType(types.integer());\n\nlexer.addTokenType(identifier());\n\nexport default lexer;\n","(function (global, factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine([\"exports\"], factory);\n\t} else if (typeof exports !== \"undefined\") {\n\t\tfactory(exports);\n\t} else {\n\t\tvar mod = {\n\t\t\texports: {}\n\t\t};\n\t\tfactory(mod.exports);\n\t\tglobal.canto34 = mod.exports;\n\t}\n})(this, function (exports) {\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\n\tvar _createClass = function () {\n\t\tfunction defineProperties(target, props) {\n\t\t\tfor (var i = 0; i < props.length; i++) {\n\t\t\t\tvar descriptor = props[i];\n\t\t\t\tdescriptor.enumerable = descriptor.enumerable || false;\n\t\t\t\tdescriptor.configurable = true;\n\t\t\t\tif (\"value\" in descriptor) descriptor.writable = true;\n\t\t\t\tObject.defineProperty(target, descriptor.key, descriptor);\n\t\t\t}\n\t\t}\n\n\t\treturn function (Constructor, protoProps, staticProps) {\n\t\t\tif (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\t\tif (staticProps) defineProperties(Constructor, staticProps);\n\t\t\treturn Constructor;\n\t\t};\n\t}();\n\n\tfunction _classCallCheck(instance, Constructor) {\n\t\tif (!(instance instanceof Constructor)) {\n\t\t\tthrow new TypeError(\"Cannot call a class as a function\");\n\t\t}\n\t}\n\n\tfunction _possibleConstructorReturn(self, call) {\n\t\tif (!self) {\n\t\t\tthrow new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t\t}\n\n\t\treturn call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t}\n\n\tfunction _inherits(subClass, superClass) {\n\t\tif (typeof superClass !== \"function\" && superClass !== null) {\n\t\t\tthrow new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t\t}\n\n\t\tsubClass.prototype = Object.create(superClass && superClass.prototype, {\n\t\t\tconstructor: {\n\t\t\t\tvalue: subClass,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t}\n\t\t});\n\t\tif (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t}\n\n\tvar util = {\n\t\tlang: {\n\t\t\tisNullOrUndefined: function isNullOrUndefined(x) {\n\t\t\t\tif (typeof x === \"undefined\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif (x === null) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\textend: function extend() {\n\t\t\t// conparable to jquery's extend\n\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\tfor (var key in arguments[i]) {\n\t\t\t\t\tif (arguments[i].hasOwnProperty(key)) arguments[0][key] = arguments[i][key];\n\t\t\t\t}\n\t\t\t}return arguments[0];\n\t\t}\n\t};\n\n\tvar PatternDefinitionException = function (_Error) {\n\t\t_inherits(PatternDefinitionException, _Error);\n\n\t\tfunction PatternDefinitionException(message) {\n\t\t\t_classCallCheck(this, PatternDefinitionException);\n\n\t\t\treturn _possibleConstructorReturn(this, (PatternDefinitionException.__proto__ || Object.getPrototypeOf(PatternDefinitionException)).call(this, message));\n\t\t}\n\n\t\treturn PatternDefinitionException;\n\t}(Error);\n\n\tvar LexerException = function (_Error2) {\n\t\t_inherits(LexerException, _Error2);\n\n\t\tfunction LexerException(message) {\n\t\t\t_classCallCheck(this, LexerException);\n\n\t\t\treturn _possibleConstructorReturn(this, (LexerException.__proto__ || Object.getPrototypeOf(LexerException)).call(this, message));\n\t\t}\n\n\t\treturn LexerException;\n\t}(Error);\n\n\tvar ParserException = function (_Error3) {\n\t\t_inherits(ParserException, _Error3);\n\n\t\tfunction ParserException(message) {\n\t\t\t_classCallCheck(this, ParserException);\n\n\t\t\treturn _possibleConstructorReturn(this, (ParserException.__proto__ || Object.getPrototypeOf(ParserException)).call(this, message));\n\t\t}\n\n\t\treturn ParserException;\n\t}(Error);\n\n\tvar Lexer = function () {\n\t\tfunction Lexer(options) {\n\t\t\t_classCallCheck(this, Lexer);\n\n\t\t\tvar defaults = {\n\t\t\t\tlanguageName: \"unnamedlanguage\"\n\t\t\t};\n\t\t\tthis.options = util.extend({}, defaults, options);\n\t\t\tthis.tokenTypes = [];\n\t\t}\n\n\t\t_createClass(Lexer, [{\n\t\t\tkey: \"addTokenType\",\n\t\t\tvalue: function addTokenType(tokenType) {\n\n\t\t\t\tif (!tokenType.name) {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types must have a 'name' property\");\n\t\t\t\t}\n\n\t\t\t\t// FOR CONSIDERATION: for some tokens, the full 'consume' is required for correct interpretation\n\t\t\t\t// (eg, JSON strings with escaped character) but a regex will do for syntax highlighting. In this\n\t\t\t\t// situation, both are allowed but consume is used for lexing and regexp is used for language definition.\n\t\t\t\t// if (tokenType.regexp && tokenType.consume) {\n\t\t\t\t// \tthrow new canto34.PatternDefinitionException(\"Token types cannot have both a 'regexp' pattern and 'consume' function.\");\n\t\t\t\t// }\n\n\t\t\t\tif (!tokenType.regexp && !tokenType.consume) {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types must have a 'regexp' property or a 'consume' function\");\n\t\t\t\t}\n\n\t\t\t\tif (tokenType.regexp && !(tokenType.regexp instanceof RegExp)) {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types 'regexp' property must be an instance of RegExp\");\n\t\t\t\t}\n\n\t\t\t\tif (tokenType.consume && typeof tokenType.consume !== \"function\") {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types 'consume' property must be a function\");\n\t\t\t\t}\n\n\t\t\t\tif (tokenType.interpret && typeof tokenType.interpret !== \"function\") {\n\t\t\t\t\tthrow new PatternDefinitionException(\"Token types 'interpret' property must be a function\");\n\t\t\t\t}\n\t\t\t\tthis.tokenTypes.push(tokenType);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"tokenize\",\n\t\t\tvalue: function tokenize(content) {\n\t\t\t\tif (content === undefined) {\n\t\t\t\t\tthrow new LexerException(\"No content provided\");\n\t\t\t\t}\n\n\t\t\t\tif (this.tokenTypes.length === 0) {\n\t\t\t\t\tthrow new LexerException(\"No token types defined\");\n\t\t\t\t}\n\n\t\t\t\tvar result = [];\n\t\t\t\tvar consumed;\n\t\t\t\tvar remaining = content;\n\t\t\t\tvar tracker = new LineTracker();\n\t\t\t\tvar tokenTypeLength = this.tokenTypes.length;\n\t\t\t\tvar consumeResult;\n\n\t\t\t\twhile (remaining.length > 0) {\n\t\t\t\t\tvar somethingFoundThisPass = false;\n\n\t\t\t\t\tfor (var i = 0; i < tokenTypeLength; i++) {\n\t\t\t\t\t\tvar tokenType = this.tokenTypes[i];\n\n\t\t\t\t\t\tconsumeResult = undefined;\n\t\t\t\t\t\tif (tokenType.consume) {\n\t\t\t\t\t\t\t// must have a consume function;\n\t\t\t\t\t\t\tconsumeResult = tokenType.consume(remaining);\n\t\t\t\t\t\t\t// should have told us what it consumed;\n\t\t\t\t\t\t\tif (consumeResult.success) {\n\t\t\t\t\t\t\t\tif (remaining.indexOf(consumeResult.consumed) !== 0) {\n\t\t\t\t\t\t\t\t\tthrow new LexerException(\"The consume function for \" + tokenType.name + \" failed to return the start of the remaining content at \" + tracker.line + \".\" + tracker.character + \" and instead returned \" + consumeResult.consumed);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tsomethingFoundThisPass = true;\n\t\t\t\t\t\t\t\t\tconsumed = consumeResult.consumed;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar match = tokenType.regexp.exec(remaining);\n\t\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t\t// we found a token! great. What did it say? We only\n\t\t\t\t\t\t\t\t// want to match at the start of the string\n\t\t\t\t\t\t\t\tif (match.index === 0) {\n\t\t\t\t\t\t\t\t\tsomethingFoundThisPass = true;\n\t\t\t\t\t\t\t\t\tconsumed = match[0];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//handle our new token\n\t\t\t\t\t\tif (tokenType.interpret) {\n\t\t\t\t\t\t\tcontent = tokenType.interpret(consumed);\n\t\t\t\t\t\t} else if (consumeResult && !util.lang.isNullOrUndefined(consumeResult.content)) {\n\t\t\t\t\t\t\tcontent = consumeResult.content;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontent = consumed;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = {\n\t\t\t\t\t\t\tcontent: content,\n\t\t\t\t\t\t\ttype: tokenType.name,\n\t\t\t\t\t\t\tline: tracker.line,\n\t\t\t\t\t\t\tcharacter: tracker.character\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (!tokenType.ignore) {\n\t\t\t\t\t\t\tresult.push(token);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tremaining = remaining.substring(consumed.length);\n\t\t\t\t\t\ttracker.consume(consumed);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!somethingFoundThisPass) {\n\t\t\t\t\t\tvar userPartOfString = remaining.substring(0, 15);\n\t\t\t\t\t\tvar visibleUserPartOfString = userPartOfString.replace(\"\\r\", \"\\\\r\").replace(\"\\t\", \"\\\\t\").replace(\"\\n\", \"\\\\n\");\n\t\t\t\t\t\tthrow new LexerException(\"No viable alternative at \" + tracker.line + \".\" + tracker.character + \": '\" + visibleUserPartOfString + \"...'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}]);\n\n\t\treturn Lexer;\n\t}();\n\n\tfunction escapeRegExp(string) {\n\t\treturn string.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n\t}\n\n\tvar StandardTokenTypes = function () {\n\t\tfunction StandardTokenTypes() {\n\t\t\t_classCallCheck(this, StandardTokenTypes);\n\t\t}\n\n\t\t_createClass(StandardTokenTypes, null, [{\n\t\t\tkey: \"constant\",\n\t\t\tvalue: function constant(literal, name, role) {\n\t\t\t\trole = role || [\"keyword\"];\n\t\t\t\treturn {\n\t\t\t\t\tname: name,\n\t\t\t\t\tregexp: new RegExp(\"^\" + escapeRegExp(literal)),\n\t\t\t\t\trole: role\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"floatingPoint\",\n\t\t\tvalue: function floatingPoint() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"floating point\",\n\t\t\t\t\tregexp: /(^-?\\d*\\.\\d+)/,\n\t\t\t\t\trole: [\"constant\", \"numeric\"],\n\t\t\t\t\tinterpret: function interpret(content) {\n\t\t\t\t\t\treturn parseFloat(content);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"integer\",\n\t\t\tvalue: function integer() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"integer\",\n\t\t\t\t\tregexp: /^-?\\d+/,\n\t\t\t\t\trole: [\"constant\", \"numeric\"],\n\t\t\t\t\tinterpret: function interpret(content) {\n\t\t\t\t\t\treturn parseInt(content);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"whitespace\",\n\t\t\tvalue: function whitespace() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"whitespace\",\n\t\t\t\t\tignore: true,\n\t\t\t\t\tregexp: /^[ \\t]+/\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"whitespaceWithNewlines\",\n\t\t\tvalue: function whitespaceWithNewlines() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"whitespace\",\n\t\t\t\t\tignore: true,\n\t\t\t\t\tregexp: /^[ \\t\\r\\n]+/\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"real\",\n\t\t\tvalue: function real() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"real number\",\n\t\t\t\t\tregexp: /^X/,\n\t\t\t\t\trole: [\"constant\", \"numeric\"]\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"comma\",\n\t\t\tvalue: function comma() {\n\t\t\t\treturn this.constant(\",\", \"comma\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"period\",\n\t\t\tvalue: function period() {\n\t\t\t\treturn this.constant(\".\", \"period\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"star\",\n\t\t\tvalue: function star() {\n\t\t\t\treturn this.constant(\"*\", \"star\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"colon\",\n\t\t\tvalue: function colon() {\n\t\t\t\treturn this.constant(\":\", \"colon\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"openParen\",\n\t\t\tvalue: function openParen() {\n\t\t\t\treturn this.constant(\"(\", \"open paren\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"closeParen\",\n\t\t\tvalue: function closeParen() {\n\t\t\t\treturn this.constant(\")\", \"close paren\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"openBracket\",\n\t\t\tvalue: function openBracket() {\n\t\t\t\treturn this.constant(\"{\", \"open bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"closeBracket\",\n\t\t\tvalue: function closeBracket() {\n\t\t\t\treturn this.constant(\"}\", \"close bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"openSquareBracket\",\n\t\t\tvalue: function openSquareBracket() {\n\t\t\t\treturn this.constant(\"[\", \"open square bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"closeSquareBracket\",\n\t\t\tvalue: function closeSquareBracket() {\n\t\t\t\treturn this.constant(\"]\", \"close square bracket\", [\"punctuation\"]);\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"JsonString\",\n\t\t\tvalue: function JsonString() {\n\t\t\t\treturn {\n\t\t\t\t\tname: \"string\",\n\t\t\t\t\tregexp: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n\t\t\t\t\tconsume: function consume(remaining) {\n\t\t\t\t\t\tvar fail = { success: false };\n\t\t\t\t\t\tif (remaining.indexOf('\"') !== 0) {\n\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar content = '';\n\t\t\t\t\t\tvar pos = 1;\n\t\t\t\t\t\tvar ch;\n\t\t\t\t\t\tvar finished = false;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tch = remaining[pos];\n\t\t\t\t\t\t\tpos += 1;\n\n\t\t\t\t\t\t\tswitch (ch) {\n\t\t\t\t\t\t\t\tcase '\"':\n\t\t\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase '\\\\':\n\t\t\t\t\t\t\t\t\tvar ch2 = remaining[pos];\n\t\t\t\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\t\t\t\tswitch (ch2) {\n\t\t\t\t\t\t\t\t\t\tcase '\"':\n\t\t\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t\t\tcase \"t\":\n\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\t\";break;\n\t\t\t\t\t\t\t\t\t\tcase \"r\":\n\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\r\";break;\n\t\t\t\t\t\t\t\t\t\tcase \"n\":\n\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\n\";break;\n\t\t\t\t\t\t\t\t\t\tcase \"u\":\n\t\t\t\t\t\t\t\t\t\t\tvar unicodeDigits = remaining.substr(pos, 4);\n\t\t\t\t\t\t\t\t\t\t\tif (unicodeDigits.length != 4 || !/\\d{4}/.test(unicodeDigits)) {\n\t\t\t\t\t\t\t\t\t\t\t\tcontent += \"\\\\u\";\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tpos += 4;\n\t\t\t\t\t\t\t\t\t\t\t\tvar codePoint = parseInt(unicodeDigits, 10);\n\t\t\t\t\t\t\t\t\t\t\t\tvar codePointString = String.fromCharCode(codePoint);\n\t\t\t\t\t\t\t\t\t\t\t\tcontent += codePointString;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t// something like \\q, which doesn't mean anything\n\t\t\t\t\t\t\t\t\t\t\treturn fail;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcontent += ch;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (!finished);\n\n\t\t\t\t\t\tvar consumed = remaining.substring(0, pos);\n\n\t\t\t\t\t\tvar successResult = {\n\t\t\t\t\t\t\tsuccess: true,\n\t\t\t\t\t\t\tconsumed: consumed,\n\t\t\t\t\t\t\tcontent: content\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn successResult;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}]);\n\n\t\treturn StandardTokenTypes;\n\t}();\n\n\tvar Parser = function () {\n\t\tfunction Parser() {\n\t\t\t_classCallCheck(this, Parser);\n\t\t}\n\n\t\t_createClass(Parser, [{\n\t\t\tkey: \"initialize\",\n\t\t\tvalue: function initialize(tokens) {\n\t\t\t\tif (!tokens) {\n\t\t\t\t\tthrow new ParserException(\"No tokens provided to the parser\");\n\t\t\t\t}\n\n\t\t\t\tif (!(tokens instanceof Array)) {\n\t\t\t\t\tthrow new ParserException(\"A non-array was provided to the parser instead of a token array\");\n\t\t\t\t}\n\n\t\t\t\tthis.tokens = tokens;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"la1\",\n\t\t\tvalue: function la1(tokenType) {\n\t\t\t\tif (this.eof()) {\n\t\t\t\t\tthrow new ParserException(\"No tokens available\");\n\t\t\t\t}\n\n\t\t\t\treturn this.tokens[0].type == tokenType;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"match\",\n\t\t\tvalue: function match(tokenType) {\n\n\t\t\t\tif (this.eof()) {\n\t\t\t\t\tthrow new ParserException(\"Expected \" + tokenType + \" but found EOF\");\n\t\t\t\t}\n\n\t\t\t\tif (!this.la1(tokenType)) {\n\t\t\t\t\tthrow new ParserException(\"Expected \" + tokenType + \" but found \" + this.tokens[0].type + \" at l\" + this.tokens[0].line + \".\" + this.tokens[0].character);\n\t\t\t\t}\n\n\t\t\t\treturn this.tokens.shift();\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"eof\",\n\t\t\tvalue: function eof() {\n\t\t\t\treturn this.tokens.length === 0;\n\t\t\t}\n\t\t}, {\n\t\t\tkey: \"expectEof\",\n\t\t\tvalue: function expectEof() {\n\t\t\t\tif (!this.eof()) {\n\t\t\t\t\tthrow new ParserException(\"Expected EOF but found \" + this.tokens[0].type + \" at l\" + this.tokens[0].line + \".\" + this.tokens[0].character);\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\n\t\treturn Parser;\n\t}();\n\n\tvar LineTracker = function () {\n\t\tfunction LineTracker() {\n\t\t\t_classCallCheck(this, LineTracker);\n\n\t\t\tthis.line = 1;\n\t\t\tthis.character = 1;\n\t\t\tthis.justSeenSlashR = false;\n\t\t}\n\n\t\t_createClass(LineTracker, [{\n\t\t\tkey: \"consume\",\n\t\t\tvalue: function consume(content) {\n\n\t\t\t\tfor (var i = 0, len = content.length; i < len; i++) {\n\t\t\t\t\tif (content[i] == \"\\r\") {\n\t\t\t\t\t\tthis.line += 1;\n\t\t\t\t\t\tthis.character = 1;\n\t\t\t\t\t\tthis.justSeenSlashR = true;\n\t\t\t\t\t} else if (content[i] == \"\\n\") {\n\t\t\t\t\t\tif (!this.justSeenSlashR) {\n\t\t\t\t\t\t\tthis.line += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.character = 1;\n\t\t\t\t\t\tthis.justSeenSlashR = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.character += 1;\n\t\t\t\t\t\tthis.justSeenSlashR = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\n\t\treturn LineTracker;\n\t}();\n\n\texports.PatternDefinitionException = PatternDefinitionException;\n\texports.LexerException = LexerException;\n\texports.ParserException = ParserException;\n\texports.Lexer = Lexer;\n\texports.StandardTokenTypes = StandardTokenTypes;\n\texports.Parser = Parser;\n\texports.LineTracker = LineTracker;\n});","import {\n  APPLICATION,\n  ASSIGNMENT,\n  BINARYOP,\n  BLOCK,\n  DEINDEX,\n  IF,\n  LAMBDA,\n  LIST,\n  LOOP,\n  NUMBER,\n  NULL,\n  RETURN,\n  STRING,\n  UNARYOP,\n  VARIABLE,\n} from './types';\n\n/**\n */\nexport function Null() {\n  return {\n    type: NULL,\n  };\n}\n\n/**\n *  elements: [Element]\n */\nexport function Block(elements) {\n  return {\n    type: BLOCK,\n    elements,\n  };\n}\n\n/**\n *  variable: Variable\n *  expression: Expression\n */\nexport function Assignment(variable, expression) {\n  return {\n    type: ASSIGNMENT,\n    variable,\n    expression,\n  };\n}\n\n/**\n *  func: Identifier\n *  args: [Expression]\n */\nexport function Application(func, args) {\n  return {\n    type: APPLICATION,\n    func,\n    args,\n  };\n}\n\n/**\n *  predicate: Expression\n *  ifBlock:   Block\n *  elseBlock: Block\n */\nexport function If(predicate, ifBlock, elseBlock = Null()) {\n  return {\n    type: IF,\n    predicate,\n    ifBlock,\n    elseBlock,\n  };\n}\n\n/**\n *  argNames:  [Identifier]\n *  body:      Block\n *  inlinable: Boolean\n */\nexport function Lambda(argNames, body) {\n  return {\n    type: LAMBDA,\n    argNames,\n    body,\n  };\n}\n\n/**\n *  value:  Expression\n */\nexport function Return(value) {\n  return {\n    type: RETURN,\n    value,\n  };\n}\n\n/**\n *  number:  Expression\n *  block:   Block\n *  loopVar: Identifier\n */\nexport function Loop(number, block, loopVar = Null()) {\n  return {\n    type: LOOP,\n    number,\n    block,\n    loopVar,\n  };\n}\n\n/**\n *  operation: String\n *  expr1: Expression\n */\nexport function UnaryOp(operator, expr1) {\n  return {\n    type: UNARYOP,\n    operator,\n    expr1,\n  };\n}\n\n/**\n *  operation: String\n *  expr1: Expression\n *  expr2: Expression\n */\nexport function BinaryOp(operator, expr1, expr2) {\n  return {\n    type: BINARYOP,\n    operator,\n    expr1,\n    expr2,\n  };\n}\n\n/**\n *  collection: Expression\n *  index: Expression\n */\nexport function DeIndex(collection, index) {\n  return {\n    type: DEINDEX,\n    collection,\n    index,\n  };\n}\n\n/**\n *  value: Number\n */\nexport function Num(value) {\n  return {\n    type: NUMBER,\n    value,\n  };\n}\n\n/**\n *  value: Identifier\n */\nexport function Variable(identifier) {\n  return {\n    type: VARIABLE,\n    identifier,\n  };\n}\n\n/**\n *  value: String\n */\nexport function Str(value) {\n  return {\n    type: STRING,\n    value,\n  };\n}\n\n/**\n *  value: List\n */\nexport function List(values) {\n  return {\n    type: LIST,\n    values,\n  };\n}\n","import { ParserException } from 'canto34';\n\nimport lexer from './lexer';\n\nimport * as ast from '../ast';\nimport * as astTypes from '../ast/types';\n\nclass ArithmaticShunter {\n  constructor() {\n    this.operatorStack = [];\n    this.output = [];\n    this.precedences = {\n      '^': 15,\n      '*': 14,\n      '/': 14,\n      '%': 14,\n      '+': 13,\n      '-': 13,\n      '<': 11,\n      '<=': 11,\n      '>': 11,\n      '>=': 11,\n      '==': 10,\n      '!=': 10,\n      '&&': 6,\n      '||': 5,\n    };\n  }\n  shuntValue(value) {\n    this.output.push(value);\n  }\n  collapseOp(op) {\n    const v2 = this.output.pop();\n    const v1 = this.output.pop();\n    const expr = ast.BinaryOp(op, v1, v2);\n    this.output.push(expr);\n  }\n  shuntOp(newOp) {\n    if (!this.precedences[newOp]) {\n      throw new ParserException(`${newOp} is not a valid operator`);\n    }\n    const peekOp = this.operatorStack[this.operatorStack.length - 1];\n    if (this.precedences[newOp] <= this.precedences[peekOp]) {\n      const topOp = this.operatorStack.pop();\n      this.collapseOp(topOp);\n    }\n    this.operatorStack.push(newOp);\n  }\n  getOutput() {\n    while (this.operatorStack.length > 0) {\n      this.collapseOp(this.operatorStack.pop());\n    }\n    if (this.output.length !== 1) {\n      throw new ParserException(\n        'Should only be a single expression in shunter output'\n      );\n    }\n    return this.output.pop();\n  }\n}\n\nclass Parser {\n  initialize(tokens) {\n    if (!tokens) {\n      throw new ParserException('No tokens provided to the parser');\n    }\n\n    if (!(tokens instanceof Array)) {\n      throw new ParserException(\n        'A non-array was provided to the parser instead of a token array'\n      );\n    }\n\n    this.tokens = tokens;\n  }\n  la1(tokenType) {\n    if (this.eof()) {\n      throw new ParserException(\n        `No tokens available: Cannot find ${tokenType}`\n      );\n    }\n\n    return this.tokens[0].type == tokenType;\n  }\n  lan(n, tokenType) {\n    if (this.eof()) {\n      throw new ParserException(\n        `No tokens available: Cannot find ${tokenType}`\n      );\n    }\n\n    return this.tokens[n - 1].type == tokenType;\n  }\n  match(tokenType) {\n    if (this.eof()) {\n      throw new ParserException(`Expected ${tokenType} but found EOF`);\n    }\n\n    if (!this.la1(tokenType)) {\n      const { type, content, line, character } = this.tokens[0];\n      throw new ParserException(\n        `Expected ${tokenType} but found ${type} (${content}) at l${line}.${character}`\n      );\n    }\n\n    return this.tokens.shift();\n  }\n  eof() {\n    return this.tokens.length === 0;\n  }\n  expectEof() {\n    if (!this.eof()) {\n      const { type, line, character } = this.tokens[0];\n      throw new ParserException(\n        `Expected EOF but found ${type} at l${line}.${character}`\n      );\n    }\n  }\n}\n\nconst parser = new Parser();\n\nparser.program = function() {\n  return this.block();\n};\n\nparser.block = function() {\n  const result = [];\n  while (!this.eof() && !this.la1('close bracket')) {\n    if (this.la1('newline')) {\n      this.match('newline');\n    } else {\n      result.push(this.statement());\n    }\n  }\n  return ast.Block(result);\n};\n\nparser.statement = function() {\n  if (this.la1('return')) {\n    this.match('return');\n    const expr = this.expression();\n    return ast.Return(expr);\n  }\n  if (this.la1('if')) {\n    return this.ifStatement();\n  }\n  if (this.la1('loop')) {\n    return this.loop();\n  }\n  if (this.lan(2, 'assignment')) {\n    return this.assignment();\n  }\n  return this.expression();\n};\n\nparser.assignment = function() {\n  const name = this.match('identifier').content;\n  this.match('assignment');\n  const expr = this.expression();\n  return ast.Assignment(ast.Variable(name), expr);\n};\n\nparser.application = function() {\n  const name = this.match('identifier').content;\n  this.match('open paren');\n  const args = this.exprList();\n  this.match('close paren');\n  return ast.Application(ast.Variable(name), args);\n};\n\n// TODO handle elseif\nparser.ifStatement = function() {\n  this.match('if');\n  const predicate = this.expression();\n  this.match('open bracket');\n  this.match('newline');\n  const ifBlock = this.block();\n  this.match('close bracket');\n  if (!this.eof() && this.la1('else')) {\n    this.match('else');\n    this.match('open bracket');\n    this.match('newline');\n    const elseBlock = this.block();\n    this.match('close bracket');\n    return ast.If(predicate, ifBlock, elseBlock);\n  }\n  return ast.If(predicate, ifBlock);\n};\n\nparser.loop = function() {\n  this.match('loop');\n  const timesExpr = this.expression();\n  this.match('times');\n  let loopVar;\n  if (this.la1('with')) {\n    this.match('with');\n    loopVar = ast.Variable(this.match('identifier').content);\n  }\n  this.match('open bracket');\n  const loopBlock = this.block();\n  this.match('close bracket');\n  return ast.Loop(timesExpr, loopBlock, loopVar);\n};\n\nparser.exprList = function() {\n  const args = [];\n  if (this.la1('close paren')) {\n    return args;\n  }\n  args.push(this.expression());\n  while (this.la1('comma')) {\n    this.match('comma');\n    args.push(this.expression());\n  }\n  return args;\n};\n\nparser.expression = function() {\n  let expr = this.baseExpression();\n  if (!this.eof() && this.la1('operator')) {\n    expr = this.arithmatic(expr);\n  }\n  return expr;\n};\n\nparser.baseExpression = function() {\n  let expr;\n  if (this.la1('open square bracket')) {\n    expr = this.list();\n  } else if (this.la1('floating point')) {\n    expr = ast.Num(this.match('floating point').content);\n  } else if (this.la1('integer')) {\n    expr = ast.Num(this.match('integer').content);\n  } else if (this.la1('operator')) {\n    expr = ast.UnaryOp(this.match('operator').content, this.expression());\n  } else if (this.la1('identifier')) {\n    expr = ast.Variable(this.match('identifier').content);\n    if (this.eof()) {\n      return expr;\n    }\n    if (this.la1('open paren')) {\n      this.match('open paren');\n      const args = this.exprList();\n      this.match('close paren');\n      expr = ast.Application(expr, args);\n    }\n  } else if (this.la1('open paren')) {\n    this.match('open paren');\n    const exprList = this.exprList();\n    this.match('close paren');\n\n    if (!this.eof() && this.la1('function arrow')) {\n      expr = this.lambda(exprList);\n    } else {\n      if (exprList.length <= 0) {\n        throw new ParserException(\n          'Cannot have an empty parenthesised expression'\n        );\n      }\n      if (exprList.length >= 2) {\n        throw new ParserException('No support for tuples, sorry');\n      }\n      expr = exprList[0];\n    }\n  } else {\n    const { type, content, line, character } = this.tokens[0];\n    throw new ParserException(\n      `Could not parse Expression on ${type} (${content}) at l${line}.${character}`\n    );\n  }\n\n  while (!this.eof() && this.la1('open square bracket')) {\n    expr = this.deindex(expr);\n  }\n\n  return expr;\n};\n\nparser.deindex = function(expr) {\n  this.match('open square bracket');\n  const deIndexExpr = this.expression();\n  this.match('close square bracket');\n  return ast.DeIndex(expr, deIndexExpr);\n};\n\nparser.arithmatic = function(firstExpr) {\n  const shunter = new ArithmaticShunter();\n  shunter.shuntValue(firstExpr);\n  while (!this.eof() && this.la1('operator')) {\n    shunter.shuntOp(this.match('operator').content);\n    shunter.shuntValue(this.baseExpression());\n  }\n  return shunter.getOutput();\n};\n\nparser.list = function() {\n  this.match('open square bracket');\n  const exprs = this.exprList();\n  this.match('close square bracket');\n  return ast.List(exprs);\n};\n\nconst exprListToArgs = exprList => {\n  return exprList.map(e => {\n    if (e.type !== astTypes.VARIABLE) {\n      throw new ParserException(\n        `Lambda definition args should not be expressions but found ${e.type}`\n      );\n    }\n    return e.identifier;\n  });\n};\n\nparser.lambda = function(exprList) {\n  const argList = exprListToArgs(exprList);\n  this.match('function arrow');\n  this.match('open bracket');\n  if (this.la1('newline')) {\n    const block = this.block();\n    this.match('close bracket');\n    return ast.Lambda(argList, block);\n  } else {\n    const expr = this.expression();\n    this.match('close bracket');\n    return ast.Lambda(argList, expr);\n  }\n};\n\nparser.nameList = function() {\n  const names = [];\n  if (this.la1('close paren')) {\n    return names;\n  }\n  names.push(this.match('identifier').content);\n  while (this.la1('comma')) {\n    this.match('comma');\n    names.push(this.match('identifier').content);\n  }\n  return names;\n};\n\nparser.parse = function(program) {\n  const tokens = lexer.tokenize(program);\n  this.initialize(tokens);\n  return this.program();\n};\n\nexport default parser;\n","import parser from './parser';\nimport lexer from './parser/lexer';\n\nexport { parser, lexer };\n"],"sourceRoot":""}